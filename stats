#!/bin/sh
pid=$$
trap "rm -rf ${pid}* exit 1" INT HUP TERM
firstChar=${1:0:1}
secondChar=${1:1:1}
average=0
median=0
tmpArray=()
smallestNum=0
sum=0
args=$#
method=0
if [ "$#" -lt 1 ] || [ "$#" -gt 2 ] ; then
	echo "Usage: stats {-rows|-cols} [file]" >&2
	exit 1
fi


if [ "$args" -eq 1 ] ; then
	inputFile="/dev/stdin"
	method=1
elif [ "$args" -eq 2 ] ; then
	inputFile=$2
fi	

if [ ! -e "$inputFile" ] || [ ! -r "$inputFile" ]; then
	echo -e "stats: cannot read \"$inputFile\"" >&2
	exit 1
fi

if [ "$firstChar" == "-" ]; then
	if [ "$secondChar" == "r" ]; then
		echo -e 'Average\tMedian'
		while read line
		do
			tmpArray=()
			average=0
			median=0
			sum=0
			sortedArray=()
			divisor=0
			roundcheck=0
			remainder=0
			
			for myWord in $line
			do
				tmpArray+=("$myWord")
				sum=`expr $sum + $myWord`
			done
			
			divisor=`expr ${#tmpArray[@]}`
			average=`expr $sum / $divisor`
			divisor=`expr $divisor \* 100`
			sum=`expr $sum \* 100`
			remainder=$(($sum % $divisor))
			
			if (("$remainder" != 0)); then
				if ((($divisor / $remainder) == 1)); then
					average=`expr $average + 1`
				elif ((($divisor % $remainder) == 0)); then
					if ((($divisor / $remainder) == 2)); then
						average=`expr $average + 1`
					fi
				fi
			fi
			# sorting concept from user 'l0b0' on StackOverFlow
			# http://stackoverflow.com/questions/9516408/sorting-in-shell-script
			sortedArray=( $(
				for i in "${tmpArray[@]}"
				do
					echo "$i"
				done | sort -n) )
			divisor=`expr $divisor / 100`
			if (( $divisor % 2 == 0 )); then
				lowerIndex=`expr ${#sortedArray[@]} / 2 - 1`
				upperIndex=`expr $lowerIndex + 1`
				if (( ${sortedArray["$lowerIndex"]} < ${sortedArray["$upperIndex"]} )); then
					median=${sortedArray["$upperIndex"]}
				else
					median=${sortedArray["$lowerIndex"]}
				fi
			else
				if index=`expr ${#sortedArray[@]} / 2`; then
					median=${sortedArray["$index"]}
				else
					median=${sortedArray[0]}
				fi
			fi
			echo -e "$average\t$median"
		done <$inputFile
	elif [ "$secondChar" == "c" ]; then
		col=0
		numCols=0
		sum=0
		average=0
		median=0
		count=0
		while read line
		do
			col=0
			for myWord in $line
			do
				col=`expr $col + 1`
				echo $myWord>>$pid"tmp"$col
			done
		done<$inputFile
		if [ -e $pid"tmp1" ]; then
			for i in $(seq 1 $col)
			do
				filename=$pid"tmp"$i
				sum=0
				count=0
				average=0
				divisor=0
				roundcheck=0
				remainder=0
				
				while read line
				do
					sum=`expr $sum + $line`
					count=`expr $count + 1`
				done<$filename
				
				cat $pid"tmp"$i | sort -n >> $pid"tmpSort"$i
				rm $pid"tmp"$i
				divisor="$count"
				average=`expr $sum / $divisor`
				divisor=`expr $divisor \* 100`
				sum=`expr $sum \* 100`
				remainder=$(($sum % $divisor))
			
				if (("$remainder" != 0)); then
					if ((($divisor / $remainder) == 1)); then
						average=`expr $average + 1`
					elif ((($divisor % $remainder) == 0)); then
						if ((($divisor / $remainder) == 2)); then
							average=`expr $average + 1`
						fi
					fi
				fi
				echo -en "$average\t">>$pid"tmpAverage"
				sortedArray=()
			
				while read line
				do
					sortedArray+=("$line")
				done<$pid"tmpSort"$i
				rm -f $pid"tmpSort"$i
				divisor=`expr $divisor / 100`
				if (( $divisor % 2 == 0)); then
					lowerIndex=`expr $count / 2 - 1`
					upperIndex=`expr $lowerIndex + 1`
					if (( ${sortedArray["$lowerIndex"]} < ${sortedArray["$upperIndex"]} )); then
						median=${sortedArray["$upperIndex"]}
					else
						median=${sortedArray["$lowerIndex"]}
					fi
				else
					if index=`expr ${#sortedArray[@]} / 2`;	then
						median=${sortedArray["index"]}
					else
						median=${sortedArray["index"]}
					fi
				fi
				echo -en "$median\t">>$pid"tmpMedian"
			done

			echo -e "\r">>$pid"tmpAverage"
			echo 'Averages:'
			cat $pid"tmpAverage"
			echo 'Medians:'
			cat $pid"tmpMedian"
			echo -e "\r"
			rm $pid"tmpAverage"
			rm $pid"tmpMedian"
		else
			echo -e 'Averages:\n'
			echo -e 'Medians:\n'
		fi
	else
		echo "Usage: stats {-rows|-cols} [file]" >&2
		exit 1
	fi
else
	echo "Usage: stats {-rows|-cols} [file]" >&2
	exit 1
fi
